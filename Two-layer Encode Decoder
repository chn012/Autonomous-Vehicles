{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "from torch.autograd import Variable\n",
    "import os, os.path \n",
    "import numpy as np\n",
    "import pickle\n",
    "from glob import glob\n",
    "import torch.nn.functional as F\n",
    "import pandas as pd\n",
    "from tqdm import tqdm\n",
    "import matplotlib.pyplot as plt\n",
    "\"\"\"Change to the data folder\"\"\"\n",
    "train_path = \"new_train/new_train\"\n",
    "pred_path=\"new_val_in/new_val_in\"\n",
    "# number of sequences in each dataset\n",
    "# train:205942  val:3200 test: 36272 \n",
    "# sequences sampled at 10HZ rate"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Create a dataset class "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "class ArgoverseDataset(Dataset):\n",
    "    \"\"\"Dataset class for Argoverse\"\"\"\n",
    "    def __init__(self, data_path: str, transform=None,p=1.0,test=False):\n",
    "        super(ArgoverseDataset, self).__init__()\n",
    "        self.data_path = data_path\n",
    "        self.transform = transform\n",
    "\n",
    "        self.pkl_list = glob(os.path.join(self.data_path, '*'))\n",
    "        self.pkl_list.sort()\n",
    "        self.test=test\n",
    "        self.p=p\n",
    "    def __len__(self):\n",
    "        return int(len(self.pkl_list)*self.p)\n",
    "\n",
    "    def __getitem__(self, idx):\n",
    "        if(self.test):\n",
    "            idx+=int(len(self.pkl_list)*self.p)\n",
    "        pkl_path = self.pkl_list[idx]\n",
    "        with open(pkl_path, 'rb') as f:\n",
    "            data = pickle.load(f)\n",
    "            \n",
    "        if self.transform:\n",
    "            data = self.transform(data)\n",
    "\n",
    "        return data\n",
    "\n",
    "\n",
    "# intialize a dataset\n",
    "val_dataset  = ArgoverseDataset(data_path=train_path,p=0.1)\n",
    "test_dataset  = ArgoverseDataset(data_path=train_path,p=0.1,test=True)\n",
    "pred_dataset  = ArgoverseDataset(data_path=pred_path)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Create a loader to enable batch processing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "batch_sz = 256\n",
    "\n",
    "#inp_shape [batch_sz,60,19,4]\n",
    "#out_shape [batch_sz,60,30,4]\n",
    "def my_collate(batch):\n",
    "    \"\"\" collate lists of samples into batches, create [ batch_sz x agent_sz x seq_len x feature] \"\"\"\n",
    "#     for scene in batch:\n",
    "#         print(scene['p_in'][numpy.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]].shape)\n",
    "#         print(scene['p_in'][numpy.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]])\n",
    "#         print(numpy.where(scene['track_id']==scene['agent_id'])[0])\n",
    "#         print(scene['lane_norm'].shape)\n",
    "#         print(scene['lane_norm'])\n",
    "#         print('lane')\n",
    "#         print(scene['lane'].shape)\n",
    "#         print(scene['lane'])  \n",
    "    inp = [np.dstack([scene['p_in'][np.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]], \n",
    "                         scene['v_in'][np.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]]]) for scene in batch]\n",
    "    out = [np.dstack([scene['p_out'][np.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]],\n",
    "                         scene['v_out'][np.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]]]) for scene in batch]\n",
    "    inp = torch.FloatTensor(inp)\n",
    "    out = torch.FloatTensor(out)\n",
    "    inp = torch.squeeze(inp, 1)\n",
    "    out = torch.squeeze(out, 1)\n",
    "\n",
    "    return [inp, out]\n",
    "\n",
    "#inp_shape [batch_sz,60,19,4]\n",
    "#scene_idx\n",
    "#indecx of each agent in each sence\n",
    "def test_collate(batch):\n",
    "    inp = [np.dstack([scene['p_in'][np.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]], \n",
    "                         scene['v_in'][np.where(scene['track_id'][:,0,:]==scene['agent_id'])[0]]]) for scene in batch]\n",
    "    inp = torch.FloatTensor(inp)\n",
    "    inp = torch.squeeze(inp, 1)\n",
    "    scene_id=[scene['scene_idx'] for scene in batch]\n",
    "    scene_id=torch.IntTensor(scene_id)\n",
    "    # index of the agent vehich \n",
    "#     agent_id_index=[] \n",
    "#      # id of the agent vehich\n",
    "#     scene_id=[]  \n",
    "#     for scene in batch:\n",
    "#         actual_objects=scene['track_id']\n",
    "#         actual_objects=actual_objects[:,0,:]\n",
    "#         agent_id_index.append(numpy.where(actual_objects==scene['agent_id'])[0])\n",
    "#         scene_id.append(scene['scene_idx'])\n",
    "    \n",
    "#     agent_id_index=torch.IntTensor(agent_id_index)\n",
    "    return [inp,scene_id]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "val_loader = DataLoader(val_dataset,batch_size=batch_sz, shuffle = True, collate_fn=my_collate, num_workers=1)\n",
    "test_loader = DataLoader(test_dataset,batch_size=batch_sz, shuffle = False, collate_fn=my_collate, num_workers=1)\n",
    "pred_loader = DataLoader(pred_dataset,batch_size=batch_sz, shuffle = False, collate_fn=test_collate, num_workers=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "class EncoderRNN(nn.Module):\n",
    "    def __init__(self, input_size=4, embedding_size=512, hidden_size=1024):\n",
    "        super(EncoderRNN, self).__init__()\n",
    "        self.hidden_size=hidden_size\n",
    "        \n",
    "        self.embd_dropout = nn.Dropout(0.4)\n",
    "        self.fc=nn.Linear(input_size,embedding_size)\n",
    "        \n",
    "        self.lstm=nn.LSTMCell(embedding_size,hidden_size)\n",
    "        self.lstm1=nn.LSTMCell(hidden_size,hidden_size)\n",
    "        \n",
    "    def forward(self,x:torch.FloatTensor,hidden,hidden1):\n",
    "        embedded=F.relu(self.fc(x))\n",
    "        embedded = self.embd_dropout(embedded)\n",
    "        hidden = self.lstm(embedded,hidden)\n",
    "        hidden = self.lstm1(hidden[0],hidden1)\n",
    "        return hidden,hidden1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "class DecoderRNN(nn.Module):\n",
    "    def __init__(self,  embedding_size=512, hidden_size=1024, output_size=4):\n",
    "        super(DecoderRNN, self).__init__()\n",
    "        self.hidden_size = hidden_size\n",
    "        self.embd_dropout = nn.Dropout(0.4)\n",
    "        self.linear1 = nn.Linear(output_size, embedding_size)\n",
    "        self.lstm = nn.LSTMCell(embedding_size, hidden_size)\n",
    "        self.lstm1 = nn.LSTMCell(hidden_size, hidden_size)\n",
    "        self.linear2 = nn.Linear(hidden_size, output_size)\n",
    "        \n",
    "    def forward(self, x,hidden,hidden1):\n",
    "        embedded = F.relu(self.linear1(x))\n",
    "        embedded = self.embd_dropout(embedded)\n",
    "        hidden = self.lstm(embedded, hidden)\n",
    "        hidden = self.lstm1(hidden[0], hidden1)\n",
    "        output = self.linear2(hidden[0])\n",
    "        return output, hidden,hidden1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "class lstm_seq2seq(nn.Module):\n",
    "    def __init__(self):\n",
    "        super(lstm_seq2seq,self).__init__()\n",
    "        self.Encoder=EncoderRNN().to(device)\n",
    "        self.Decoder=DecoderRNN().to(device)\n",
    "    def forward(self,x,forcing=False,out=None):\n",
    "        input_length = x.shape[1]\n",
    "        batch_size = x.shape[0]\n",
    "   \n",
    "        encoder_hidden= (\n",
    "            torch.zeros(batch_size, self.Encoder.hidden_size).to(device),\n",
    "            torch.zeros(batch_size, self.Encoder.hidden_size).to(device),\n",
    "        )\n",
    "        encoder_hidden1= (\n",
    "            torch.zeros(batch_size, self.Encoder.hidden_size).to(device),\n",
    "            torch.zeros(batch_size, self.Encoder.hidden_size).to(device),\n",
    "        )\n",
    "        for ei in range(input_length-1):\n",
    "            encoder_input = x[:, ei, :]-x[:, ei+1, :]\n",
    "            encoder_hidden,encoder_hidden1 = self.Encoder(encoder_input,encoder_hidden,encoder_hidden1)\n",
    "        \n",
    "        rollout_len=30\n",
    "        decoder_input=encoder_input\n",
    "        \n",
    "        decoder_hidden = encoder_hidden\n",
    "        decoder_hidden1 = encoder_hidden1\n",
    "        # shape of output batch_size*object timestep feature\n",
    "        decoder_outputs= torch.zeros((x.size(0),rollout_len,x.size(2))).to(device)    \n",
    "        decoder_outputs[:,0,:]=x[:,-1,:]\n",
    "        \n",
    "        \n",
    "        for di in range(rollout_len):\n",
    "            decoder_output, decoder_hidden,decoder_hidden1 = self.Decoder(decoder_input,decoder_hidden,decoder_hidden1)\n",
    "            decoder_input=decoder_output\n",
    "            # Update loss\n",
    "            if(di==0):\n",
    "                decoder_outputs[:, di, :] += decoder_output\n",
    "                if forcing:\n",
    "                    decoder_input=out[:,di,:]-x[:,-1,:]\n",
    "            else:\n",
    "                decoder_outputs[:, di, :] = decoder_output+decoder_outputs[:, di-1, :]\n",
    "                if forcing:\n",
    "                    decoder_input=out[:,di,:]-out[:,di-1,:]\n",
    "        return  decoder_outputs\n",
    "#     def predict(self,x):\n",
    "#         input_length = x.shape[1]\n",
    "#         batch_size = x.shape[0]\n",
    "   \n",
    "#         encoder_hidden= (\n",
    "#             torch.zeros(batch_size, self.Encoder.hidden_size).to(device),\n",
    "#             torch.zeros(batch_size, self.Encoder.hidden_size).to(device),\n",
    "#         )\n",
    "#         for ei in range(input_length-1):\n",
    "#             encoder_input = x[:, ei, :]-x[:, ei+1, :]\n",
    "#             encoder_hidden = self.Encoder(encoder_input,encoder_hidden)\n",
    "        \n",
    "#         rollout_len=30\n",
    "#         decoder_input=encoder_input\n",
    "        \n",
    "#         decoder_hidden = encoder_hidden\n",
    "#         # shape of output batch_size*object timestep feature\n",
    "#         decoder_outputs= torch.zeros((x.size(0),rollout_len,x.size(2))).to(device)    \n",
    "#         decoder_outputs[:,0,:]=x[:,-1,:]\n",
    "        \n",
    "#         #loss trnsor\n",
    "#         for di in range(rollout_len):\n",
    "#             decoder_output, decoder_hidden = self.Decoder(decoder_input,decoder_hidden)\n",
    "#             decoder_input = decoder_output\n",
    "#             # Update loss\n",
    "#             if(di==0):\n",
    "#                 decoder_outputs[:, di, :] += decoder_output\n",
    "#             else:\n",
    "#                 decoder_outputs[:, di, :] = decoder_output+decoder_outputs[:, di-1, :]\n",
    "#         return  decoder_outputs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Visualize the batch of sequences"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import random\n",
    "\n",
    "\n",
    "\n",
    "def show_sample_batch(sample_batch):\n",
    "    \"\"\"visualize the trajectory for a batch of samples with a randon agent\"\"\"\n",
    "    inp, out,perd = sample_batch\n",
    "    batch_sz = inp.size(0)\n",
    "    \n",
    "    fig, axs = plt.subplots(1,4, figsize=(15, 3), facecolor='w', edgecolor='k')\n",
    "    fig.subplots_adjust(hspace = .5, wspace=.001)\n",
    "    axs = axs.ravel()   \n",
    "    for i in range(4):\n",
    "        axs[i].xaxis.set_ticks([])\n",
    "        axs[i].yaxis.set_ticks([])\n",
    "        # first two feature dimensions are (x,y) positions\n",
    "        axs[i].scatter(inp[i,:,0], inp[i,:,1])\n",
    "        axs[i].scatter(out[i,:,0], out[i,:,1])\n",
    "        axs[i].scatter(out[i,:,0], perd[i,:,1])\n",
    "    plt.show()\n",
    "    \n",
    "# seq2seq rnn\n",
    "def train(val_loader,model,Optimizer,device):\n",
    "    total_loss=0\n",
    "    model.train()\n",
    "    decoder_outputs=0\n",
    "    count=0\n",
    "    for i_batch, sample_batch in enumerate(tqdm(val_loader)):\n",
    "        inp, out = sample_batch\n",
    "        \n",
    "        inp,out=inp.to(device),out.to(device)\n",
    "\n",
    "    \n",
    "        # reshape batch_size*object timestep feature\n",
    "        loss = 0\n",
    "        Optimizer.zero_grad()\n",
    "\n",
    "        # shape of output batch_size*object timestep feature\n",
    "        decoder_outputs=model(inp,forcing=False,out=out)\n",
    "\n",
    "        loss=(torch.mean((decoder_outputs-out)**2))**0.5\n",
    "\n",
    "        total_loss+=loss.item()\n",
    "        # Backpropagate\n",
    "        loss.backward()\n",
    "        Optimizer.step()\n",
    "        count+=1\n",
    "\n",
    "        # sample\n",
    "        #show_sample_batch((inp.cpu(),out.cpu(),decoder_outputs.cpu().detach().numpy()))\n",
    "    print(\"total:{}\".format(total_loss/count))    \n",
    "    return total_loss/count\n",
    "    \"\"\"TODO:\n",
    "      Deep learning model\n",
    "      training routine\n",
    "    \"\"\"\n",
    "#show_sample_batch(sample_batch, agent_id)\n",
    "# break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def test(test_loader,model,device):\n",
    "    model.eval()\n",
    "    total_loss=0\n",
    "    count=0\n",
    "    with torch.no_grad():\n",
    "        for inp,out in test_loader:\n",
    "            inp,out=inp.to(device),out.to(device)\n",
    "            \n",
    "            decoder_outputs=model(inp)\n",
    "            loss=(torch.mean((decoder_outputs-out)**2))**0.5\n",
    "\n",
    "            total_loss+=loss.item()\n",
    "            count+=1;\n",
    "    return total_loss/count "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def predict(pred_loader,model,device):\n",
    "    model.eval()\n",
    "    perd_p_out=torch.zeros((1,61)).to(device)\n",
    "    with torch.no_grad():\n",
    "        for inp , scene_id in pred_loader:\n",
    "            inp,scene_id=inp.to(device),scene_id.to(device)\n",
    "            \n",
    "            decoder_outputs=model(inp)\n",
    "            batch_size=decoder_outputs.size(0)\n",
    "            # submistion formatting \n",
    "            for i in range(batch_size):\n",
    "                #one agent perdition \n",
    "                temp=torch.cat(((scene_id[i].reshape(1,1)).float(),decoder_outputs[i,:,:2].reshape(60,1)),dim=0).to(device)\n",
    "                temp=temp.reshape(1,61)\n",
    "                #stack all agent perdtion\n",
    "                perd_p_out=torch.cat((perd_p_out,temp),dim=0)         \n",
    "    return perd_p_out "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "is_cuda = torch.cuda.is_available()\n",
    "\n",
    "if is_cuda:\n",
    "    device = torch.device(\"cuda\")\n",
    "else:\n",
    "    device = torch.device(\"cpu\")\n",
    "model=lstm_seq2seq().to(device)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "from torch.optim.lr_scheduler import StepLR\n",
    "momentum = 0.9\n",
    "# batch size is 100 \n",
    "# error=nn.MSELoss()\n",
    "# np.exp(-10)\n",
    "learning_rate=0.001\n",
    "Optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\n",
    "scheduler = StepLR(Optimizer, step_size=100, gamma=0.1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\r",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "epoch 0\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:35<00:00,  2.30it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:8.419661592554164\n",
      "epoch 1\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.74it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:6.566938541553639\n",
      "epoch 2\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.78it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:5.61610777584123\n",
      "epoch 3\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.70it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:5.459828959570991\n",
      "epoch 4\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.78it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:5.656593475812747\n",
      "epoch 5\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:13<00:00,  5.80it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:5.524355052429953\n",
      "epoch 6\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.76it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:5.456015180658411\n",
      "epoch 7\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.73it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:5.177425143159466\n",
      "epoch 8\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.73it/s]\n",
      "  0%|          | 0/81 [00:00<?, ?it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:5.255965350586691\n",
      "epoch 9\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 81/81 [00:14<00:00,  5.74it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "total:4.993141686474836\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "num_epoch = 10\n",
    "train_loss=np.zeros((num_epoch,))\n",
    "#test_loss=np.zeros((num_epoch,))\n",
    "for epoch in range(0, num_epoch):\n",
    "    print(\"epoch\",epoch)\n",
    "    train_loss[epoch]=train(val_loader,model,Optimizer,device)\n",
    "    #test_loss[epoch]=test(test_loader,model,device)\n",
    "    scheduler.step()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "from matplotlib.pyplot import figure\n",
    "\n",
    "figure(figsize=(8, 6), dpi=80)\n",
    "x_ax=np.linspace(1, num_epoch, num_epoch)\n",
    "\n",
    "plt.plot(x_ax,train_loss,label='train')\n",
    "#plt.plot(x_ax,test_loss,label='test')\n",
    "plt.xlabel(\"Epochs\")\n",
    "plt.ylabel(\"loss\")\n",
    "#plt.ylim(1,5)\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "29402116\n"
     ]
    }
   ],
   "source": [
    "print(sum(p.numel() for p in model.parameters()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "sample_p=predict(pred_loader,model,device)\n",
    "#remove the zero\n",
    "sample_p=sample_p[1:,:]\n",
    "\n",
    "for inp,scene_id in pred_loader:\n",
    "    inp,scene_id.to(device)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "data=pd.read_csv('sample_submission.csv', index_col=False)\n",
    "if is_cuda:\n",
    "    sample_p=sample_p.cpu()\n",
    "sample_p_df=pd.DataFrame(sample_p.numpy(),columns=data.columns)\n",
    "sample_p_df['ID']=sample_p_df['ID'].astype(int)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "sample_p_df.to_csv('sample_test.csv',index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ex= torch.zeros((4,)).to(device)\n",
    "# ex_seq=torch.zeros((4,)).to(device)\n",
    "# count=0\n",
    "# for i_batch,sample_batch in enumerate(val_loader):\n",
    "#     inp,out=sample_batch\n",
    "#     inp= inp.to(device).float()\n",
    "#     out= out.to(device).float()\n",
    "#     mixed=torch.cat((inp,out),1).to(device)\n",
    "#     mixed=mixed.reshape((-1,4))\n",
    "#     count=len(mixed)+count\n",
    "#     ex=(ex+torch.sum(mixed,0))\n",
    "#     ex_seq=ex_seq+torch.sum(mixed**2,0)\n",
    "# mean=ex/count\n",
    "# variance=mean**2-ex_seq/count\n",
    "# std=(-variance)**0.5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "# X= [ .....]\n",
    "# for x in X :\n",
    "#     if x is not 0;\n",
    "#         accept \n",
    "#     else \n",
    "#         if m accept w \n",
    "#             accept \n",
    "#         else\n",
    "#             reject "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "2651682ea206448e88014e4eddb3fa10": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HBoxModel",
      "state": {
       "children": [
        "IPY_MODEL_cae5deeb37934a18bfc5fa24b2c84dcd",
        "IPY_MODEL_f18b0035a89b4b0b9ac003c6e0b106f3"
       ],
       "layout": "IPY_MODEL_9dd12bc2db3347989de692da7ba500db"
      }
     },
     "2cdb6fc45a9e4d06bd51ddc56d957120": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "description_width": ""
      }
     },
     "92bdcec2c1194c59964c95a9951b7b93": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "9dd12bc2db3347989de692da7ba500db": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "b492e50625544f77a37f7fd44e63ce25": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {}
     },
     "bc2f5de58e5944c687b439e191ff9db6": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "description_width": "initial"
      }
     },
     "cae5deeb37934a18bfc5fa24b2c84dcd": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "FloatProgressModel",
      "state": {
       "bar_style": "danger",
       "description": "  4%",
       "layout": "IPY_MODEL_b492e50625544f77a37f7fd44e63ce25",
       "max": 51486,
       "style": "IPY_MODEL_bc2f5de58e5944c687b439e191ff9db6",
       "value": 1881
      }
     },
     "f18b0035a89b4b0b9ac003c6e0b106f3": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "layout": "IPY_MODEL_92bdcec2c1194c59964c95a9951b7b93",
       "style": "IPY_MODEL_2cdb6fc45a9e4d06bd51ddc56d957120",
       "value": " 1881/51486 [04:22&lt;1:55:33,  7.15it/s, loss=2.72e+3]"
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
